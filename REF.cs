using System;

namespace refg
{
    internal class Program
{
        //передача аргументов по ссылке
        //1. Без ref. 
        //    static void Foo(int a)
        //    {
        //        a = -5;
        //    }
        //static void Main(string[] args)
        //{
        //        int b = 2;
        //        Foo(b);
        //        Console.WriteLine(b);
        //при вызове метода Foo данные из переменной b копируются в переменную a.
        //на экран будет выведено значение 2.

        //2. REF СО ЗНАЧИМЫМ ТИПОМ ДАННЫХ.
        //static void Foo(ref int a)
        //{
        //    a = -5;
        //}

        //static void Main(string[] args)
        //{
        //    int b = 4;
        //    Foo(ref b);
        //    Console.WriteLine(b);
        //}
        //Параметр, который будет приниматься в методе Foo, передается по ссылке, а не 
        //по значению. Это не копирование данных из одной переменной в другую.
        //Раз параметр передается по ссылке, то работать мы будет с ОДНИМИ И ТЕМИ ЖЕ ДАННЫМИ.
        //Если параметр принимается по ссылке, то и передаваться он должен также.
        //Получили ЗНАЧИМЫЙ тип данных, с ПОВЕДЕНИЕМ ССЫЛОЧНОГО. 
        //Изначально ссылались на одну и ту же область в оперативной памяти,
        // в дальнейшем эта область была изменена, и эти изменеия повлияли на исходную переменную. 
        //ref - это как создание ярлка на другом диске. Файл может быть гигантским
        //Если не используем ключевое слово, то копируем весь файл. А если используем,
        //то объем данных, гоняемых туда-сюда, по итогу меньше.

        //3.БЕЗ REF СО ССЫЛОЧНЫМИ ТИПАМИ ДАННЫХ.
        //static void Bar(int[] myArray)
        //{
        //    myArray[0] = -5;
        //}

        //static void Main (string[] args)
        //{
        //    int[] array = { 1, 2, 4, 5 };

        //    Bar(array);
        //    Console.WriteLine(array[0]);
        //}
        //Работаем с одной областью данных, на которую ссылаются оба массива.
        //В итоге, в массиве array элемент под индексом 0 станет -5 вместо изначально
        //указанного 1. 
        //Ref  имеет смысл для самой ссылки, которая ссылается на эти данные,
        //т.е. для имени массива. 

        //3.1 БЕЗ REF СО ССЫЛОЧНЫМИ ДАННЫМИ СО ЗНАЧЕНИЕМ NULL В МЕТОДЕ BAR.
        //static void Bar(int[] myArray)
        //{
        //    myArray = null;
        //}

        //static void Main(string[] args)
        //{
        //    int[] array = { 1, 2, 5, 6 };
        //    Bar(array);
        //    Console.WriteLine(array[1]);
        //}
        //В предыдущем примере получалось менять значения элементов массива.
        //но теперь при присвоении массиву в методе Bar значения null 
        //оборвалась связь ссылки с управляемой кучей, где ранее хранились данные.
        //Поэтому теперь с этими данным невозможно что-то сделать.
        //После того, как была покинута область значения метода Bar,
        //в нашем массиве не null, а остаются данные.
        //Когда обращаемся к элементу массива при помощи фигурных скобок, и меняем
        //его значение, то мы работаем С ДАННЫМИ массива, который расположены
        //в управляемой куче, на которую ссылается массив.
        //А когда мы пытаемся присвоить всем массиву новое значение или null,
        //то мы работаем не с данным в управляемой куче, а с САМОЙ ССЫЛКОЙ.
        //то есть мы пытаемся изменить саму ссылку. Имя массива - это адрес некой
        //области в оперативной памяти. Этот адрес нужно где-то хранить для получения доступа
        //к элементам массива. Переменная myArray - та область, где мы храним адрес. 
        // И когда мы передаем ее в метод Bar, то создается другая переменная, в которую
        //мы копируем адрес. То есть у нас есть 2 РАЗНЫЕ переменные, которые хранят одну 
        //и ту же ссылку на данные в управляемой куче. Это 2 разных ярлыка, которые ссылаются
        //на один и тот же файл. Если мы у одного ярлыка сотрем путь к файлу, то это не означает,
        //что тоже самое произойдет и с другим файлом. 

        //4.1 REF СО ССЫЛОЧНЫМИ ДАННЫМИ null
        //static void Bar( ref int[] myArray)
        //{
        //    myArray = null;
        //}

        //static void Main(string[] args)
        //{
        //    int[] array = { 1, 2, 5, 6 };
        //    Bar(ref array);
        //    Console.WriteLine(array[1]);
        //}
        //Теперь в обоих массивах будет null, так как мы передали ссылку по сслыке,
        //а не скопировали ее. 
        //при работе со ссылочными данными, возможно изменять их данные при передаче
        //их куда-то в качестве параметра. Но если передаем ссылочный тип данных
        //без ключевого слова, то невозможно что-то сделать с самой ссылкой, т.к.
        // это просто копия ссылки. 

        //4.2 БЕЗ REF СО ССЫЛОЧНЫМИ ДАННЫМИ С СОЗДАНИЕМ НОВОГО МАССИВА.
        //static void Bar(int[] myArray)
        //{
        //    myArray = new int[10];
        //    myArray[0] = 8;
        //}

        //static void Main(string[] args)
        //{
        //    int[] array = { 1, 2, 5, 6 };
        //    Bar(array);
        //    Console.WriteLine(array[0]);
        //}
        //Имеем 2 разные переменные с одним и тем же адресом по ссылке. 
        //В управляемой куче выделили новую область, взяли новый адрес и присвоили
        //новую ссылку. Но на масси в методе Main это не оказало никакого влияния.
        //Как только вы вышли из метода Bar, ссылка из той области видимости была
        //удалена и массив myArray остался висеть где-то в управляемой куче. 

        //4.3 REF СО ССЫЛОЧНЫМИ ДАННЫМИ С СОЗДАНИЕМ НОВОГО МАССИВА.
        //static void Bar(ref int[] myArray)
        //{
        //    myArray = new int[10];
        //    myArray[0] = 8;
        //}

        //static void Main(string[] args)
        //{
        //    int[] array = { 1, 2, 5, 6 };
        //    Bar(ref array);
        //    Console.WriteLine(array[0]);
        //}
        //А теперь имя myArray ссылается на адрес array. это означает, что если
        //в массиве myArray что-то поменять, то это скажется на массиве array.
        //ссылку на массив с 4-мя элементами мы "затерли", заменив ее ссылкой массива
        //на 10 элементов. 

        //5.0 ССЫЛОЧНЫЕ ЛОКАЛЬНЫЕ ПЕРЕМЕННЫЕ.

        //static void Main(string[] args)
        //{
        //    int[] array = { 1, 2, 5, 6 };
        //    int b = array[0];
        //    b = -5;
        //    Console.WriteLine(array[0]);
        //}
        //в этом случае переменная b никак не влияет на массив, потому что между ними
        //нет связи. 
        static void Main(string[] args)
        {
           int[] array = { 1, 2, 5, 6 };
           ref int b =ref  array[0];
           b = -5;
           Console.WriteLine(array[0]);
        }
        //теперь переменная b стала ссылочной локальной. Это означает, что мы обратимся
        //к такому элементу по ссылке. В этом случае мы не копировали переменную из массива
        //а ссылаемся именно на ту переменную в массиве. 
    }
}

